#!/usr/bin/env sh

# Dmenu for managing passwords.

# MIT License
#
# Copyright (c) 2020 Alexander Chaplin Braz (http://alexchaplinbraz.com)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

if ! command -v genrepass 1> /dev/null 2>&1; then
	printf "ERROR: 'genrepass' is required for password generation.\n"
	exit 1
fi

ScriptName=${0##*/}
Version=1.0.0

suggest_help() {
	printf "Try '%s --help' for more information.\n" "$ScriptName"
}

err() {
	printf 'ERROR: %s' "$2"
	[ $1 -gt 0 ] && exit $1
}

# Compose the help message:
HelpMessage="$ScriptName - Version: $Version
Creator: Alexander Chaplin Braz (http://alexchaplinbraz.com)
License: MIT

Usage: $ScriptName ['genrepass options']

This script lets the user copy, add, edit and delete pass entries through a
series of dmenu prompts.

The script itself requires no arguments, but does require the user to have the
complimentary genrepass utility by the same creator for password generation.

The default options for genrepass are:
'-s' to use its own source code as file input
'-C' to capitalize each word for better readability
but the user can override that by passing them as the first argument. Do make
sure to quote the whole block of options and arguments that you would normally
pass to genrepass with single quotes.

Another way to set the options is to export an environment variable named
DPASS_OPTS, which takes the same format. This way you can simply run
$ScriptName without any options.

IMPORTANT: avoid using the '-c' for copying to clipboard because this script
           is set up in a way that pipes the stdout of genrepass into dmenu for
           you to see.

Keep in mind the pinentry program used for entering your passphrase to decrypt
your .gpg files. If it's set to a terminal one, this script won't work properly.
I personally recommend pinentry-dmenu to keep with the dmenu theme.

The editor is taken from \$EDITOR as used by pass.

Examples:
    $ScriptName '-tCf \"\$HOME/Documents/Journal-2020.md\"'
    $ScriptName '-s --min-pass-len 30 --max-pass-len 50 --num-amount 10'

    export PASS_OPTS='-tCf \"\$HOME/Documents/Journal-2020.md\"'
    $ScriptName

Pro tip:
You can also pass a command substitution. My favourite is selecting a random
file to be used as input. For example:
	export DPASS_OPTS='-Cf \"\$(find \"\$HOME/notes\" -type f | shuf -n1)\"'
Would find all the files insides the notes directory and select a random one
to be used for your password generation.
"

case $1 in
	-h|--help)
		printf '%s' "$HelpMessage"; exit 0 ;;
	-v|--version)
		printf '%s - Version: %s\n' "$ScriptName" "$Version"; exit 1
	*|'')
		printf '%s' "$HelpMessage"; exit 1 ;;
esac

# Get the location of the password store:
PWStore=$PASSWORD_STORE_DIR
[ -z "$PWStore" ] && PWStore="$HOME/.password-store"

# Get a list of all entries:
PassList=$(find $PWStore -name "*.gpg" | sed "s/\.gpg$//; s|$PWStore/||g")

# Set menu options:
MenuCopy='1. Copy entry to clipboard.'
MenuCreate='2. Create new entry/Edit existing entry.'
MenuEdit="3. Edit entry with $EDITOR."
MenuDelete='4. Delete an entry.'
FullMenu="$MenuCopy\n$MenuCreate\n$MenuEdit\n$MenuDelete"

# Prompt user to choose action:
ChosenMenu=$(printf '%b' "$FullMenu" | dmenu -i -l 10 -p "dpass:")

# Copy selected entry to clipboard:
if [ "$ChosenMenu" = "$MenuCopy" ]; then
	ChosenPass=$(
		printf '%s' "$PassList" | dmenu -i -l 30 -p 'Choose an entry to copy:'
	)

	pass show -c "$ChosenPass"

# Create new entry/Edit existing entry:
elif [ "$ChosenMenu" = "$MenuCreate" ]; then
	ChosenName=$(
		printf '%s' "$PassList" | dmenu -i -l 30 -p 'Input entry name:'
	)

	[ -z "$ChosenName" ] && exit 1

	# Set menu options:
	TypeGenrepass='1. Generate password with genrepass.'
	TypeSingleLine='2. Write a single line of content.'

	# Prompt user to choose content type:
	ChosenType=$(
		printf '%s\n%s' "$TypeGenrepass" "$TypeSingleLine" \
			| dmenu -i -l 10 -p 'Choose content type:'
	)

	# Generate password with genrepass:
	if [ "$ChosenType" = "$TypeGenrepass" ];then

		# Set genrepass options:
		 if [ -z "$1" ] && [ "$DPASS_OPTS" ]; then
			GRPargs=$DPASS_OPTS
		 elif [ -z "$1" ]; then
			GRPargs='-sC'
		 else
			GRPargs=$1
		 fi

		# Keep generating passwords until one is selected:
		while [ -z "$Content" ]; do
			Content=$(
				eval genrepass "$GRPargs" | dmenu -l 10 \
					-p 'ENTER to select, ESCAPE to generate new password:'
			)
		done

	# Input custom single line content:
	elif [ "$ChosenType" = "$TypeSingleLine" ];then
		Content=$(printf '' | dmenu -p 'Input content:')

	elif [ -z "$ChosenType" ];then
		exit 1
	else
		printf 'ERROR: invalid selection.\n'
		suggest_help
		exit 1
	fi

	# Create a preview for the user to see their input:
	Confirmation=$(
		printf '%s\nEntry: %s\nContent: %s' \
			'This is a preview. Press ENTER to confirm or ESCAPE to cancel.' \
			"$ChosenName" "$Content" | dmenu -i -l 10
	)

	# If the user pressed ENTER, create/edit the entry:
	if [ "$Confirmation" ]; then
		printf '%s' "$Content" | pass add --echo --force "$ChosenName"
	fi

# Open entry with $EDITOR:
elif [ "$ChosenMenu" = "$MenuEdit" ]; then
	ChosenPass=$(
		printf "%s" "$PassList" | dmenu -i -l 30 -p "Choose an entry to edit:"
	)

	$TERMINAL -e pass edit "$ChosenPass"

# Delete an entry:
elif [ "$ChosenMenu" = "$MenuDelete" ]; then
	ChosenPass=$(
		printf '%s' "$PassList" | dmenu -i -l 30 -p 'Choose an entry to delete:'
	)

	pass delete --force "$ChosenPass"

elif [ -z "$ChosenMenu" ]; then
	exit 1
else
	printf 'ERROR: invalid selection.\n'
	suggest_help
	exit 1
fi
